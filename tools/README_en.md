
# Proto_auto guide

This document describes how to use C# syntax to describe custom protocol files and protocol generation process
# What proto_auto does

###  1.Protocol file generation

The proto_auto project can generate a custom protocol format based on the DLL file, so that the C++ program can recognize (such as C++ enum or struct). Both the client and the server read the unified protocol code file, simplifying the protocol definition. The code generated by different services is saved to different C++ files.
The advantage of this is that when all the code is regenerated when a service is modified, only the C++ file of the modified protocol is changed, which can reduce the time for recompiling the system.

###  2.Client and server code generation for rpc service
The rpc interface of all interfaces of each service can be generated. The specific service logic only needs to inherit the related base class to complete the interface logic. For details, refer to [crucis_proto introduction] (../README.md).

## Comments

Comments follow the C# syntax. Use double slashes "//" to comment entire lines. Multiple lines of comments use /**/


## Optional label

### `Desc` tag
Descriptive text uses the form of [Desc("xx")] before the type. When generating the protocol, the parentheses can be used to generate comments.
### `Label` tag
Like [Label(LabelType.Required)], only LabelType.Required is currently supported, indicating that it must not be empty.
### `PSSingleton` tag
Indicates that it is a singleton type. It is generally used to describe the interface interface, similar to ImitateSingleton.
### `ProcessOn` tag
Similar to [ProcessOn(ProcessOnType.Client)], it can only be used on an interface function to indicate which side the interface is mainly called to. ProcessOnType is defined as
```csharp
 public enum ProcessOnType
 {
    All,
    Client,
    Server,
 } 
```  
  
## basic type

Supports the following standard data types:
* PSVoid Corresponds to void in C++
* PSInt32 corresponds to int32_t in C++
* PSUInt32 corresponds to uint32_t in C++
* PSSInt32 corresponds to int32_t in C++, but compresses negative numbers during transmission
* PSFixed32 corresponds to uint32_t in C++ without any compression
* PSInt64 corresponds to int64_t in C++
* PSUInt64 corresponds to uint64_t in C++
* PSDouble corresponds to double in C++
* PSFloat corresponds to float in C++
* PSString corresponds to std::string in C++
* PSBinary corresponds to uint8_t[] in C++

## List type

Support complex type definition list, for example: PSList, where types in angle brackets currently only support the previous standard data types

## enumerate

Used to define enumeration data in the following format: qualifier type + enum + name {}. Each enum type is separated by a comma. Example is as follows
```csharp
[Desc("Message Behavior Type")]
Public enum MessageType
{
    [Desc("Call")]
    Call = 1,
    [Desc("Return")]
    Reply = 2,
    [Desc("Exception")]
    Exception = 3,
    [Desc ("Single")]
    Oneway = 4
}
```
## Struct

Used to define the structure type, format: modifier type + class + name {}, where each field needs to be preceded by an [Index(xx)] tag, and the xx number is incremented from 1 in sequence. Example:
```csharp
 Public class RpcRequestData
 {
    [Index(1)]
    [Label(LabelType.Required)]
    [Desc("Service type id number")]
    Public PSUInt32 ServiceId;

    [Index(2)]
    [Label(LabelType.Required)]
    [Desc("id number of the function")]
    Public PSUInt32 Function;
}
```

## Interface Type

Used to define services and interfaces in the form of modifier type + interface + name {}. The following example defines the NewServiceSingleton interface and NewService interface under the ServiceFactory service.
```csharp
[Index(0)]
[PSSingleton()]
[Desc("Remote Service Object Generator, Used to Generate Service Objects Remotely")]
Public interface ServiceFactory
{
   //Create a new service
   [Index(1)]
   PSVoid NewServiceSingleton(PSUInt32 serviceType);

   [Index(2)]
   [Desc("Synchronize Locally Existing Service to Remote")]
   PSVoid NewService(PSUInt32 serviceType, PSUInt64 objectId);
}
```
The input and output parameters support the standard data types mentioned earlier as well as the enum and struct types.

**Note**: The service definition generally adds an Index tag to the service. The number is globally unique. It is easy to locate the service class by number. The index number on the interface indicates the corresponding interface. In this way, through the above two Index numbers, you can locate a specific interface. 